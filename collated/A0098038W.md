# A0098038W
###### ./ErrorSuppressor.java
``` java
package memori;

import java.io.OutputStream;
import java.io.PrintStream;

public class ErrorSuppressor {
	public static PrintStream originalErr = System.err;
	
	/**Redirects the System.err to another stream */
	public static void supress(){
		System.setErr(new PrintStream(new OutputStream() {
		    public void write(int b) {
		    }
		}));
	}
	/**Redirects back the System.err */
	public static void unsupress(){
		System.setErr(originalErr);
	}
}
```
###### ./googleSync/EventConverter.java
``` java
package memori.googleSync;

import java.util.Calendar;
import java.util.Date;

import com.google.api.client.util.DateTime;
import com.google.api.services.calendar.model.Event;
import com.google.api.services.calendar.model.EventDateTime;

import memori.logic.MemoriEvent;

public class EventConverter {
	private static final String UNNAMED = "Unnamed Google Event";
	public static final Date END_OF_TIME = new Date(9999999999999L);
	public static final Date START_OF_TIME = new Date(-9999999999999L);

	public static Event toGoogle(MemoriEvent me) {
		Event event = new Event();
		DateTime end;
		DateTime start;
		if (me.getStart() != null) {
			start = new DateTime(me.getStart());
		} else {
			start = new DateTime(START_OF_TIME);
		}
		if (me.getEnd() != null) {
			end = new DateTime(me.getEnd());
		} else {
			end = new DateTime(END_OF_TIME);

		}
		event.setSummary(me.getName());
		event.setLocation(me.getLocation());
		event.setDescription(me.getDescription());
		event.setStart(new EventDateTime().setDateTime(start));
		event.setEnd(new EventDateTime().setDateTime(end));
		event.setId(me.getExternalCalId());
		return event;
	}

	public static MemoriEvent toMemori(Event ge) {
		if (ge == null)
			return null;
		String name = ge.getSummary();
		if (name == null) {
			name = UNNAMED;
		}
		String description = ge.getDescription();
		DateTime startDT = ge.getStart().getDateTime();
		DateTime endDT = ge.getEnd().getDateTime();
		if (startDT == null) {
			startDT = ge.getStart().getDate();
		}
		if (endDT == null) {
			endDT = ge.getEnd().getDate();
		}
		Date start = new Date(startDT.getValue());
		Date end = new Date(endDT.getValue());
		Calendar cal = Calendar.getInstance();
		cal.setTime(START_OF_TIME);
		int startOfTimeYear = cal.get(Calendar.YEAR);
		int startOfTimeMonth = cal.get(Calendar.MONTH);
		int startOfTimeDay = cal.get(Calendar.DAY_OF_MONTH);
		cal.setTime(END_OF_TIME);
		int endOfTimeYear = cal.get(Calendar.YEAR);
		int endOfTimeMonth = cal.get(Calendar.MONTH);
		int endOfTimeDay = cal.get(Calendar.DAY_OF_MONTH);
		cal.setTime(start);
		int startYear = cal.get(Calendar.YEAR);
		int startMonth = cal.get(Calendar.MONTH);
		int startDay = cal.get(Calendar.DAY_OF_MONTH);
		cal.setTime(end);
		int endYear = cal.get(Calendar.YEAR);
		int endMonth = cal.get(Calendar.MONTH);
		int endDay = cal.get(Calendar.DAY_OF_MONTH);
		if (startYear == startOfTimeYear && startMonth == startOfTimeMonth && startDay == startOfTimeDay) {
			start = null;
		}
		if (endYear == endOfTimeYear && endMonth == endOfTimeMonth && endDay == endOfTimeDay) {
			end = null;
		}
		String location = ge.getLocation();
		int internalId = MemoriEvent.INTERNAL_ID_WILDCARD;
		String externalId = ge.getId();
		if(description == null){
			description = "";
		}
		if(location == null){
			location = "";
		}
		MemoriEvent me = new MemoriEvent(name, start, end, internalId, externalId, description, location);
		me.setExternalCalId(ge.getId());
		return me;

	}
}
```
###### ./googleSync/GoogleCRUD.java
``` java
package memori.googleSync;

import java.io.IOException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;

import com.google.api.services.calendar.model.Event;
import com.google.api.services.calendar.model.Events;

import memori.logic.MemoriEvent;
import memori.parsers.MemoriCommand;

public class GoogleCRUD {
	/** Modes for Google Calendar operations */
	private static final int ADD = 0;
	private static final int UPDATE = 1;
	private static final int RETRIEVE = 2;
	private static final int DELETE = 3;

	/** Modes for Google Calendar operations */
	private static final String CALENDAR_ID = "primary";
	private static final int MAX_RESULTS = 100000;

	/** Service Object used to authenticate the program */
	private com.google.api.services.calendar.Calendar googleCalendar;

	/** Constructor */
	public GoogleCRUD(com.google.api.services.calendar.Calendar googleCalendar) {
		this.googleCalendar = googleCalendar;
	}

	public boolean executeCmd(MemoriEvent me, MemoriCommand cmd) {
		switch (cmd.getType()) {
		case ADD:
			return addEvent(me);
		case UPDATE:
			return updateEvent(me);
		case DELETE:
			return deleteEvent(me);
		default:
			return false;
		}
	}

	public MemoriEvent retrieveRemote(MemoriEvent me) {
		try {
			Event event = new Event();
			event.setId(me.getExternalCalId());
			event = executeEvent(event, RETRIEVE);
			return EventConverter.toMemori(event);
		} catch (UnknownHostException e) {
			return null;
		} catch (IOException e) {
			return null;
		}
	}

	public ArrayList<MemoriEvent> retrieveAllEvents() throws IOException, UnknownHostException {
		Events events = googleCalendar.events().list(CALENDAR_ID).setMaxResults(MAX_RESULTS).execute();
		List<Event> items = events.getItems();
		ArrayList<MemoriEvent> remoteCopy = new ArrayList<MemoriEvent>();
		for (Event e : items) {
			remoteCopy.add(EventConverter.toMemori(e));
		}
		return remoteCopy;
	}

	/**
	 * Converts a MemoriEvent object to a Google Calendar Event object and adds
	 * it to Google Calendar
	 * 
	 * @param memoriEvent
	 *            the local event that needs to be sync
	 * @return completion status of the operation
	 */
	private boolean addEvent(MemoriEvent memoriEvent) {
		Event event = EventConverter.toGoogle(memoriEvent);

		try {
			event = executeEvent(event, ADD);
			memoriEvent.setExternalCalId(event.getId());
		} catch (UnknownHostException e) {
			return false;
		} catch (IOException e) {
			return false;
		}
		return true;
	}

	/**
	 * Converts a MemoriEvent object to a Google Calendar Event object and
	 * update it on Google Calendar
	 * 
	 * @param memoriEvent
	 *            the local event that needs to be sync
	 * @return completion status of the operation
	 */
	private boolean updateEvent(MemoriEvent memoriEvent) {

		Event event = EventConverter.toGoogle(memoriEvent);
		String GcalEventId = memoriEvent.getExternalCalId();

		try {
			if (GcalEventId != null) {
				event.setId(GcalEventId);
				event = executeEvent(event, UPDATE);
			} else {
				event = executeEvent(event, ADD);
				memoriEvent.setExternalCalId(event.getId());
			}
		} catch (UnknownHostException e) {
			return false;
		} catch (IOException e) {
			return false;
		}

		return true;
	}

	/**
	 * Deletes an MemoriEvent on Google
	 * 
	 * @param memoriEvent
	 *            the local event that needs to be sync
	 * @return completion status of the operation
	 */
	private boolean deleteEvent(MemoriEvent memoriEvent) {
		Event event = new Event();
		String externalId = memoriEvent.getExternalCalId();
		if (externalId != null) {
			event.setId(externalId);
		} else {
			return true;
		}
		try {
			event = executeEvent(event, DELETE);
		} catch (UnknownHostException e) {
			return false;
		} catch (IOException e) {
			return true;
		}
		return true;
	}

	/**
	 * 
	 * @param event
	 *            a Google Event Object to be added/updated/Delete
	 * @param mode
	 *            Update/Retrieve/Add/Delete
	 * @return an update Google Event object after performing the operation
	 * @throws IOException
	 *             when incorrect Google Calendar Id or Start and End are
	 *             entered
	 * @throws UnknownHostException
	 *             when there is no connection to Google Calendar
	 */
	private Event executeEvent(Event event, int mode) throws IOException, UnknownHostException {
		switch (mode) {
		case ADD:
			return googleCalendar.events().insert(CALENDAR_ID, event).execute();
		case UPDATE:
			return googleCalendar.events().update(CALENDAR_ID, event.getId(), event).execute();
		case RETRIEVE:
			return googleCalendar.events().get(CALENDAR_ID, event.getId()).execute();
		case DELETE:
			googleCalendar.events().delete(CALENDAR_ID, event.getId()).execute();
		default:
			return null;
		}
	}
}
```
###### ./googleSync/GoogleCRUDTest.java
``` java
package memori.googleSync;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Date;

import org.junit.BeforeClass;
import org.junit.Test;

import memori.logic.MemoriEvent;
import memori.parsers.DateParser;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;

public class GoogleCRUDTest {
	
	private com.google.api.services.calendar.Calendar googleCalendar = GCalConnect.getCalendarService();
	private GoogleCRUD crud = new GoogleCRUD(googleCalendar);
	private static final String NAME = "test name";
	private static final Date START = DateParser.parseDate("today");
	private static final Date END = DateParser.parseDate("today");
	private static final String LOCATION = "location";
	private static final String DESCRIPTION = "description";
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		
	}

	@Test
	public void testExecuteAddEvent() {
		MemoriEvent  me = new  MemoriEvent(NAME, START, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		Boolean status  = crud.executeCmd(me, cmd);
		String externalId = me.getExternalCalId();
		MemoriEvent remote = crud.retrieveRemote(me);
		assertTrue(status);
		assertTrue(me.equals(remote));
	
	}
	
	@Test
	public void testNoStart(){
		MemoriEvent  me = new  MemoriEvent(NAME, END, START, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		Boolean status  = crud.executeCmd(me, cmd);
		MemoriEvent remote = crud.retrieveRemote(me);
		assertTrue(me.equals(remote));
		assertTrue(status);
	}
	@Test
	public void testExecuteAddDeadLine() {
		MemoriEvent  me = new  MemoriEvent(NAME, null, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		Boolean status  = crud.executeCmd(me, cmd);
		MemoriEvent remote = crud.retrieveRemote(me);
		assertTrue(status);
		assertTrue(me.equals(remote));
	}
	@Test
	public void testExecuteAddFloat() {
		MemoriEvent  me = new  MemoriEvent(NAME, null, null, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		Boolean status  = crud.executeCmd(me, cmd);
		MemoriEvent remote = crud.retrieveRemote(me);
		String externalIdtoUpdate = me.getExternalCalId();
		assertTrue(status);
		assertTrue(me.equals(remote));
	}
	@Test
	public void testUpdatewithNoEID(){
		MemoriEvent  me = new  MemoriEvent(NAME + "Updated", null, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.UPDATE);
		Boolean status  = crud.executeCmd(me, cmd);
		MemoriEvent remote = crud.retrieveRemote(me);
		assertTrue(status);
		assertTrue(me.equals(remote));
	}
	@Test
	public void testUpdatewithEID(){
		MemoriEvent  me = new  MemoriEvent(NAME, START, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		String externalId = me.getExternalCalId();
		me = new  MemoriEvent(NAME + "Updated", null, END, 0,externalId, LOCATION,DESCRIPTION);
		cmd  = new MemoriCommand(MemoriCommandType.UPDATE);
		Boolean status  = crud.executeCmd(me, cmd);
		MemoriEvent remote = crud.retrieveRemote(me);
		assertTrue(status);
		assertTrue(me.equals(remote));
	}
	@Test
	public void testDeletewtihNoEID(){
		MemoriEvent  me = new  MemoriEvent(NAME, null, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.DELETE);
		Boolean status  = crud.executeCmd(me, cmd);
		assertTrue(status);
	}
	@Test
	public void testDeletewtihEID(){
		MemoriEvent  me = new  MemoriEvent("DELETE", START, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		crud.executeCmd(me, cmd);
		String externalId = me.getExternalCalId();
		me = new  MemoriEvent(NAME, null, END, 0,externalId, LOCATION,DESCRIPTION);
		cmd  = new MemoriCommand(MemoriCommandType.DELETE);
		Boolean status  = crud.executeCmd(me, cmd);
		assertTrue(status);
	}


}
```
###### ./googleSync/MemoriSync.java
``` java
package memori.googleSync;

import java.io.IOException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;

import memori.ErrorSuppressor;
import memori.Storage.MemoriStorage;
import memori.logic.MemoriCalendar;
import memori.logic.MemoriEvent;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;

public class MemoriSync {
	/** Initial Sync Messages */
	private static final String PULL_MESSAGE = "Number of events added locally =%1$s\n";
	private static final String PUSH_MESSAGE = "Number of events synced to google =%1$s\n";
	private static final String PUSH_ERROR = "Unable to sync local events to Google Calendar right now\n";
	private static final String PULL_ERROR = "Unable to pull your events from google\n";

	/** Service Object used to authenticate the program */
	private com.google.api.services.calendar.Calendar googleCalendar;

	/** Component used to perform CRUD functions on Google */
	private GoogleCRUD crud;

	/**
	 * A copy of all the Google Calendar events converted to memoriEvent objects
	 */
	private ArrayList<MemoriEvent> remoteCopy;

	/** Mark a list of events to not remove from Google during initial sync */
	private ArrayList<MemoriEvent> doNotDelete;

	/** Connection Status */
	private boolean isConnected;

	/** A queue of objects to manage what to sync */
	private Queue<SyncObject> thingsToSync;

	/**
	 * MemoriStorage Component to save the syncing queue if the program is
	 * offline
	 */
	private MemoriStorage st;

	/** Default constructor */
	public MemoriSync() {
		ErrorSuppressor.supress();
		googleCalendar = GCalConnect.getCalendarService();
		ErrorSuppressor.unsupress();
		st = MemoriStorage.getInstance();
		SyncObjectQueue wrapper = st.loadQueue();
		if (wrapper == null) {
			thingsToSync = new LinkedList<SyncObject>();
		} else {
			thingsToSync = wrapper.theQueue;
		}
		Queue<SyncObject> tempQueue = new LinkedList<SyncObject>();
		while (!thingsToSync.isEmpty()) {
			SyncObject current = thingsToSync.poll();
			if (current.getCommand().getType() == MemoriCommandType.DELETE) {
				tempQueue.offer(current);
			}
		}
		doNotDelete = new ArrayList<MemoriEvent>();
		thingsToSync = tempQueue;
	}

	/**
	 * Performs the initial syncing
	 *
	 * @param localCopy
	 *            emoriCalendar Object used in this instance of the program
	 * @return A string that indicates the initial sync status
	 */
	public String initialize(MemoriCalendar calendar) {
		String output = "";
		if (googleCalendar != null) {
			crud = new GoogleCRUD(googleCalendar);
			try {
				processQueue();
				remoteCopy = crud.retrieveAllEvents();
				isConnected = true;
				output += pullEvents(calendar);
				output += pushEvents(calendar);
				checkForConflicts(calendar);
			} catch (UnknownHostException e) {
				isConnected = false;
				output += PUSH_ERROR;
				output += PULL_ERROR;
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return output;
	}

	/**
	 * Checks Events on Google Calendar and adds the missing ones to Memori
	 *
	 * @param localCopy
	 *            MemoriCalendar Object used in this instance of the program
	 * @return A string that indicates how many events were added to Memori
	 */
	private String pullEvents(MemoriCalendar localCopy) {
		localCopy.sortBy(MemoriEvent.externalIdComparator);
		ArrayList<MemoriEvent> localEvents = localCopy.getEvents();
		ArrayList<MemoriEvent> toBeAdded = new ArrayList<MemoriEvent>();
		for (MemoriEvent e : remoteCopy) {
			// not found
			if (Collections.binarySearch(localEvents, e, MemoriEvent.externalIdComparator) < 0) {
				toBeAdded.add(e);
			}
		}
		for (MemoriEvent e : toBeAdded) {
			localCopy.addRemote(e);
		}
		return String.format(PULL_MESSAGE, toBeAdded.size());
	}

	/**
	 * Checks for Events in Memori that were not synced up to Google Calendar
	 * and push them up
	 *
	 * @param localCopy
	 *            MemoriCalendar Object used in this instance of the program
	 * @return A string that indicates how many events were added to Google
	 */
	private String pushEvents(MemoriCalendar localCopy) {
		ArrayList<MemoriEvent> localEvents = localCopy.getEvents();
		ArrayList<MemoriEvent> toBePushed = new ArrayList<MemoriEvent>();
		MemoriCommand addCommand = new MemoriCommand(MemoriCommandType.ADD);
		for (MemoriEvent e : localEvents) {
			if (e.getExternalCalId() == null) {
				toBePushed.add(e);
			}
		}
		for (MemoriEvent e : toBePushed) {
			addNewRequest(e, addCommand);
			doNotDelete.add(e);
		}
		if (thingsToSync.isEmpty())
			return String.format(PUSH_MESSAGE, toBePushed.size());
		else
			return PUSH_ERROR;
	}

	/**
	 * Compare existing Events on Memori and Google. If a Google Event differs
	 * from Memori use latest update time to resolve conflict. If a Memori Event
	 * has a Google Event Id but is no longer found on Google, delete that event
	 * from Memori
	 *
	 * @param localCopy
	 *            MemoriCalendar Object used in this instance of the program
	 */
	private void checkForConflicts(MemoriCalendar localCopy) {
		ArrayList<MemoriEvent> localEvents = localCopy.getEvents();
		ArrayList<SyncObject> toGoogle = new ArrayList<SyncObject>();
		ArrayList<Integer> toDelete = new ArrayList<Integer>();
		Collections.sort(remoteCopy, MemoriEvent.externalIdComparator);

		markForDeleteOrUpdate(localEvents, toGoogle, toDelete);
		deleteFromLocal(localEvents, toDelete);
		updateGoogleEvents(toGoogle);

	}

	/**
	 * Marking the Events for Delete or Update
	 *
	 * @param localEvents
	 *            An ArrayList of MemoriEvents found in the Calendar Object
	 * @param toGoogle
	 *            An ArrayList of MemoriEvents that has been marked for update
	 *            to Google
	 * @param toDelete
	 *            An ArrayList of indexes of the MemoriEvents marked for
	 *            deletion
	 */
	private void markForDeleteOrUpdate(ArrayList<MemoriEvent> localEvents, ArrayList<SyncObject> toGoogle,
			ArrayList<Integer> toDelete) {
		for (int i = 0; i < localEvents.size(); i++) {
			MemoriEvent currentLocal = localEvents.get(i);
			int result = Collections.binarySearch(remoteCopy, currentLocal, MemoriEvent.externalIdComparator);
			// event was updated
			if (result >= 0) {
				MemoriEvent currentRemote = remoteCopy.get(result);
				if (!currentLocal.equals(currentRemote)) {
					solveDifferences(currentLocal, currentRemote, toGoogle);
				}
				// event was not found so it was deleted from Gcal
			} else if (!doNotDelete.contains(currentLocal)) {
				toDelete.add(i);
			}
		}
	}

	/**
	 * Solve differences in Attributes based on Update time
	 *
	 * @param currentLocal
	 *            A copy of the event found locally on Memori
	 * @param currentRemote
	 *            A copy of the event found remotely on Google Calendar
	 * @param toGoogle
	 *            An ArrayList of MemoriEvents that has been marked for update
	 *            to Google
	 */
	private void solveDifferences(MemoriEvent currentLocal, MemoriEvent currentRemote, ArrayList<SyncObject> toGoogle) {
		if (currentRemote.getUpdate().after(currentLocal.getUpdate())) {
			currentLocal.replace(currentRemote);
		} else {
			MemoriCommand updateCmd = new MemoriCommand(MemoriCommandType.UPDATE);
			SyncObject toUpdate = new SyncObject(updateCmd, currentLocal);
			toGoogle.add(toUpdate);
		}
	}

	/**
	 * Sends update requests to Google Calendar
	 * 
	 * @param toGoogle
	 *            An ArrayList of MemoriEvents that has been marked for update
	 *            to Google
	 */
	private void updateGoogleEvents(ArrayList<SyncObject> toGoogle) {
		for (int i = 0; i < toGoogle.size(); i++) {
			MemoriEvent e = toGoogle.get(i).getEvent();
			MemoriCommand cmd = toGoogle.get(i).getCommand();
			addNewRequest(e, cmd);
		}
	}

	/**
	 * Delete events that are no longer found on Google Calendar
	 * 
	 * @param localEvents
	 * @param toDelete
	 *            An ArrayList of Indxes to delete from local Events
	 */
	private void deleteFromLocal(ArrayList<MemoriEvent> localEvents, ArrayList<Integer> toDelete) {
		Collections.reverse(toDelete);
		for (int i = 0; i < toDelete.size(); i++) {
			int index = toDelete.get(i);
			localEvents.remove(index);
		}
	}

	/**
	 * Add a request to the things to SyncQueue
	 * 
	 * @param memoriEvent
	 * @param cmd
	 */
	public void addNewRequest(MemoriEvent memoriEvent, MemoriCommand cmd) {
		SyncObject newEntry = new SyncObject(cmd, memoriEvent);
		thingsToSync.offer(newEntry);
		isConnected = true;
		if (crud != null) {
			processQueue();
		}
	}

	/** Processes whatever item is in thingsToSync Queue */
	private void processQueue() {
		while (isConnected) {
			SyncObject headOfQueue = thingsToSync.peek();
			if (headOfQueue != null) {
				isConnected = crud.executeCmd(headOfQueue.getEvent(), headOfQueue.getCommand());
				if (isConnected) {
					thingsToSync.poll();
				}
			} else {
				break;
			}
		}
		SyncObjectQueue wrapper = new SyncObjectQueue();
		wrapper.theQueue = thingsToSync;
		st.saveQueue(wrapper);
	}

	/**
	 * Checks what type of undo is required and performs it on Google Calendar
	 * 
	 */
	public void undo(ArrayList<MemoriEvent> previous, ArrayList<MemoriEvent> next) {
		Collections.sort(previous, MemoriEvent.internalIdComparator);
		Collections.sort(next, MemoriEvent.internalIdComparator);
		// undo was an undoing an update if it was a complete nothing will sync
		if (previous.size() == next.size()) {
			undoUpdate(previous, next);

		}
		// if undo was undoing an add
		else if (previous.size() < next.size()) {
			undoAdd(previous, next);
		}
		// if undo was undoing an delete
		else {
			undoDelete(previous, next);
		}
	}

	/** Undo a delete on Google Calendar */
	private void undoDelete(ArrayList<MemoriEvent> previous, ArrayList<MemoriEvent> next) {
		for (int i = 0; i < previous.size(); i++) {
			MemoriEvent current = previous.get(i);
			if (!next.contains(current)) {
				MemoriCommand addCmd = new MemoriCommand(MemoriCommandType.ADD);
				thingsToSync.add(new SyncObject(addCmd, current));
			}
		}
		processQueue();
	}

	/** Undo a update on Google Calendar */
	private void undoUpdate(ArrayList<MemoriEvent> previous, ArrayList<MemoriEvent> next) {
		MemoriEvent toUpdate;
		for (int i = 0; i < previous.size(); i++) {
			if (!previous.get(i).equals(next.get(i))) {
				toUpdate = previous.get(i);
				toUpdate.setExternalCalId(next.get(i).getExternalCalId());
				MemoriCommand updateCmd = new MemoriCommand(MemoriCommandType.UPDATE);
				thingsToSync.add(new SyncObject(updateCmd, toUpdate));
				processQueue();
				break;
			}
		}
	}

	/** Undo a add on Google Calendar */
	private void undoAdd(ArrayList<MemoriEvent> previous, ArrayList<MemoriEvent> next) {
		for (int i = 0; i < next.size(); i++) {
			MemoriEvent current = next.get(i);
			if (!previous.contains(current)) {
				MemoriCommand deleteCmd = new MemoriCommand(MemoriCommandType.DELETE);
				thingsToSync.add(new SyncObject(deleteCmd, current));
				processQueue();
			}
		}
	}

	/** Retrieve a remote Copy of the MemoriEvent */
	public MemoriEvent retrieveRemote(MemoriEvent local) {
		MemoriEvent remote = crud.retrieveRemote(local);
		if (remote != null) {
			return remote;
		} else {
			isConnected = false;
			return null;
		}
	}

	/**
	 * Retrieve what's on Google Calendar and convert it to Memori Event Format
	 */
	public ArrayList<MemoriEvent> retrieveAll() {
		try {
			return crud.retrieveAllEvents();
		} catch (UnknownHostException e) {
			return null;
		} catch (IOException e) {
			return null;
		}

	}

	/**
	 * @return connection status to Google Calendar
	 */
	public boolean IsConnected() {
		return isConnected;
	}

}
```
###### ./googleSync/MemoriSyncTest.java
``` java
package memori.googleSync;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.Date;

import org.junit.BeforeClass;
import org.junit.Test;

import memori.logic.MemoriCalendar;
import memori.logic.MemoriEvent;
import memori.parsers.DateParser;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;
import memori.ui.MemoriUI;

public class MemoriSyncTest {
	private static MemoriSync ms = new MemoriSync();
	private static MemoriCalendar calendar = new MemoriCalendar();
	private static final String NAME = "test name";
	private static final Date START = DateParser.parseDate("today");
	private static final Date END = DateParser.parseDate("today");
	private static final String LOCATION = "location";
	private static final String DESCRIPTION = "description";
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		ms.initialize(calendar);
		calendar.initialize();
		calendar.display();
	}

	@Test
	public void testAddNewRequestAdd() {
		MemoriEvent  me = new  MemoriEvent(NAME, START, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		ms.addNewRequest(me, cmd);
		MemoriEvent remote = ms.retrieveRemote(me);
		assertTrue(me.equals(remote));
	}
	
	@Test
	public void testAddNewRequestDelete() {
		MemoriEvent  me = new  MemoriEvent("DELETE", START, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		ms.addNewRequest(me, cmd);
		cmd  = new MemoriCommand(MemoriCommandType.DELETE);
		ms.addNewRequest(me, cmd);
		ArrayList<MemoriEvent> afterDelete = ms.retrieveAll();
		assertTrue(!afterDelete.contains(me));
	}
	
	@Test
	public void testAddNewRequestUpdate() {
		MemoriEvent  me = new  MemoriEvent(NAME, START, END, 0,null, LOCATION,DESCRIPTION);
		MemoriCommand cmd  = new MemoriCommand(MemoriCommandType.ADD);
		ms.addNewRequest(me, cmd);
		String externalID = me.getExternalCalId();
		MemoriEvent me2  = new MemoriEvent(NAME + "UPDATED", START, END, 0,externalID, LOCATION,DESCRIPTION);
		cmd  = new MemoriCommand(MemoriCommandType.UPDATE);
		ms.addNewRequest(me2, cmd);
		MemoriEvent remote = ms.retrieveRemote(me);
		assertTrue(me2.equals(remote));
	}
	
}
```
###### ./googleSync/SyncObject.java
``` java
package memori.googleSync;

import memori.logic.MemoriEvent;
import memori.parsers.MemoriCommand;

/**Just a wrapper class to wrap MemoriCommand and object together*/
public class SyncObject {
	/**The command that needs to be performed to the object*/
	private MemoriCommand cmd;
	/**The command that needs to be performed to the object*/
	private MemoriEvent event;
	
	
	public SyncObject(MemoriCommand cmd, MemoriEvent event) {
		this.cmd = cmd;
		this.event = event;
	}
	
	public MemoriCommand getCommand(){
		return this.cmd;
	}
	
	public MemoriEvent getEvent(){
		return this.event;
	}
}
```
###### ./googleSync/SyncObjectQueue.java
``` java
package memori.googleSync;

import java.util.LinkedList;
import java.util.Queue;

/** Just a wrapper class to facilitate GSON library when converting to JSON */
public class SyncObjectQueue {
	public Queue<SyncObject> theQueue;

	public SyncObjectQueue() {
		theQueue = new LinkedList<SyncObject>();
	}

}
```
###### ./logic/MemoriCalendarTest.java
``` java
package memori.logic;

import static org.junit.Assert.assertTrue;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;

import org.junit.BeforeClass;
import org.junit.Test;

import com.google.api.services.calendar.Calendar;

import memori.ErrorSuppressor;
import memori.googleSync.GCalConnect;
import memori.googleSync.MemoriSync;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;
import memori.ui.MemoriUI;

public class MemoriCalendarTest {

	private static final String MESSAGE_ADD = "Event Added.\n";
	private static final String MESSAGE_DELETE = "Event Deleted.\n";
	private static final String MESSAGE_NO_RESULTS = "No results found\n";
	private static final String MESSAGE_READ = "Reading: %1$d \n";
	private static final String MESSAGE_SORT = "Sorted.\n";
	private static final String MESSAGE_UPDATE = "Updated Event %1$d \n";
	private static final String MESSAGE_INVALID_INDEX = "Line index does not exists.\n";
	private static final String MESSAGE_INVALID_INPUT_NAME = "Invalid input. Name should not be empty. \n";
	private static final String MESSAGE_INVALID_INPUT_START = "Invalid input. New start date should not be later"
			+ " than original end date. \n";
	private static final String MESSAGE_INVALID_INPUT_END = "Invalid input. New end date should not be earlier"
			+ " than original start date. \n";
	private static final String MESSAGE_INVALID_INPUT_GENERAL = "Invalid input. \n";
	private static final String MESSAGE_COMPLETE = "Tasks have been marked complete. \n";
	private static final String MESSAGE_OPEN = "Tasks have been reopened\n";
	private static final String MESSAGE_EMPTYFILE = "File is Empty.\n";
	private static final String MESSAGE_CHANGE_SEARCH = "Your search conditions has been changed\n";

	private MemoriCalendar calendar = new MemoriCalendar();

	private MemoriSync google = new MemoriSync();

	private Calendar service = GCalConnect.getCalendarService();
	private MemoriUI ui = new MemoriUI();

	@BeforeClass
	public static void setUpBforeClass() throws Exception {

	}

	public void initialize() {
		ErrorSuppressor.supress();
		try {
			service.calendars().clear("primary").execute();
		} catch (IOException e) {
			e.printStackTrace();
		}
		calendar = new MemoriCalendar();
		google = new MemoriSync();
		calendar.initialize();
		google.initialize(calendar);
		calendar.display();
	}
	@Test
	public void testExecuteAddEvent() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		String observed = calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		MemoriEvent latestEvent = main.get(main.size() - 1);
		assertTrue(observed.contains(MESSAGE_ADD));
		assertTrue(expectedEvent.equals(latestEvent));
	}
	@Test
	public void testExecuteAddDeadline() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = new Date();
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		String observed = calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		MemoriEvent latestEvent = main.get(main.size() - 1);
		assertTrue(observed.contains(MESSAGE_ADD));
		assertTrue(expectedEvent.equals(latestEvent));
	}
	@Test
	public void testExecuteAddNoEnd() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = null;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		String observed = calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		MemoriEvent latestEvent = main.get(main.size() - 1);
		assertTrue(observed.contains(MESSAGE_ADD));
		assertTrue(expectedEvent.equals(latestEvent));
	}
	@Test
	public void testExecuteAddFloat() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		String observed = calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		MemoriEvent latestEvent = main.get(main.size() - 1);
		assertTrue(observed.contains(MESSAGE_ADD));
		assertTrue(expectedEvent.equals(latestEvent));
	}
	@Test
	public void testExecuteDeleteOne() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		ArrayList<Integer> indexes = new ArrayList<Integer>();
		indexes.add(1);
		calendar.display();
		mc = new MemoriCommand(MemoriCommandType.DELETE, indexes);
		calendar.execute(mc, google);

		assertTrue(!main.contains(latestEvent));
	}
	@Test
	public void testExecuteDeleteMultiple() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		ArrayList<Integer> indexes = new ArrayList<Integer>();
		for (int i = 0; i < 10; i++) {
			calendar.execute(mc, google);
			indexes.add(i + 1);
		}
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		calendar.display();
		mc = new MemoriCommand(MemoriCommandType.DELETE, indexes);
		calendar.execute(mc, google);
		assertTrue(!main.contains(latestEvent));
	}
	@Test
	public void testExecuteUpdateName() {
		initialize();
		Boolean[] memoriField = new Boolean[] { true, false, false, false, false };
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		int index = 1;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		calendar.execute(mc, google);
		fieldStr[0] = "updated";
		calendar.display();
		mc = new MemoriCommand(MemoriCommandType.UPDATE, start, end, fieldStr, index, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		assertTrue(latestEvent.equals(expectedEvent));
	}
	@Test
	public void testExecuteUpdateStart() {
		initialize();
		Boolean[] memoriField = new Boolean[] { false, true, false, false, false };
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		int index = 1;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		calendar.execute(mc, google);
		start = new Date();
		calendar.display();
		mc = new MemoriCommand(MemoriCommandType.UPDATE, start, end, fieldStr, index, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		assertTrue(latestEvent.equals(expectedEvent));
	}
	@Test
	public void testExecuteUpdateEnd() {
		initialize();
		Boolean[] memoriField = new Boolean[] { false, false, true, false, false };
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		int index = 1;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		calendar.execute(mc, google);
		end = new Date();
		calendar.display();
		mc = new MemoriCommand(MemoriCommandType.UPDATE, start, end, fieldStr, index, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		assertTrue(latestEvent.equals(expectedEvent));
	}
	@Test
	public void testExecuteUpdateLocation() {
		initialize();
		Boolean[] memoriField = new Boolean[] { false, false, false, true, false };
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		int index = 1;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		calendar.execute(mc, google);
		calendar.display();
		fieldStr[1] = "updated";
		mc = new MemoriCommand(MemoriCommandType.UPDATE, start, end, fieldStr, index, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		assertTrue(latestEvent.equals(expectedEvent));
	}
	@Test
	public void testExecuteUpdateDescription() {
		initialize();
		Boolean[] memoriField = new Boolean[] { false, false, false, false, true };
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		int index = 1;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		calendar.execute(mc, google);
		calendar.display();
		fieldStr[2] = "updated";
		mc = new MemoriCommand(MemoriCommandType.UPDATE, start, end, fieldStr, index, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		MemoriEvent expectedEvent = new MemoriEvent(fieldStr[0], start, end, 0, null, fieldStr[2], fieldStr[1]);
		assertTrue(latestEvent.equals(expectedEvent));
	}
	@Test
	public void testExecuteSortName() {
		initialize();
		String[] fieldStr = new String[] { "", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		Boolean[] memoriField = new Boolean[] { true, false, false, false, false };
		MemoriCommand mc;
		String[] names = new String[] { "5", "name", "123name", "HELLO", "hello", "blah" };
		for (int i = 0; i < names.length; i++) {
			fieldStr[0] = names[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}
		mc = new MemoriCommand(MemoriCommandType.SORT, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> sorted = calendar.getEvents();
		boolean sortStatus = true;

		for (int i = 0; i < sorted.size() - 1; i++) {
			String first = sorted.get(i).getName();
			String second = sorted.get(i + 1).getName();
			if (first.compareToIgnoreCase(second) > 0) {
				sortStatus = false;
				break;
			}
		}
		assertTrue(sortStatus);
	}
	@Test
	public void testExecuteSortStart() {
		initialize();
		String[] fieldStr = new String[] { "", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		Boolean[] memoriField = new Boolean[] { false, true, false, false, false };
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		Date[] startDates = new Date[] { new Date(888888888L), new Date(222222222222L), new Date(3333333333333L),
				new Date(0), new Date() };
		for (int i = 0; i < startDates.length; i++) {
			start = startDates[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}
		mc = new MemoriCommand(MemoriCommandType.SORT, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> sorted = calendar.getEvents();
		boolean sortStatus = true;

		for (int i = 0; i < sorted.size() - 1; i++) {
			Date first = sorted.get(i).getStart();
			Date second = sorted.get(i + 1).getStart();
			if (first.compareTo(second) > 0) {
				sortStatus = false;
				break;
			}
		}
		assertTrue(sortStatus);
	}
	@Test
	public void testExecuteSortEnd() {
		initialize();
		String[] fieldStr = new String[] { "", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		Boolean[] memoriField = new Boolean[] { false, false, true, false, false };
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		Date[] endDates = new Date[] { new Date(888888888L), new Date(222222222222L), new Date(3333333333333L),
				new Date(0), new Date() };
		for (int i = 0; i < endDates.length; i++) {
			end = endDates[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}
		mc = new MemoriCommand(MemoriCommandType.SORT, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> sorted = calendar.getEvents();
		boolean sortStatus = true;

		for (int i = 0; i < sorted.size() - 1; i++) {
			Date first = sorted.get(i).getEnd();
			Date second = sorted.get(i + 1).getEnd();
			if (first.compareTo(second) > 0) {
				sortStatus = false;
				break;
			}
		}
		assertTrue(sortStatus);
	}
	@Test
	public void testExecuteSortDescription() {
		initialize();
		String[] fieldStr = new String[] { "name", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		Boolean[] memoriField = new Boolean[] { false, false, false, false, true };
		MemoriCommand mc;
		String[] names = new String[] { "5", "name", "123name", "HELLO", "hello", "blah" };
		for (int i = 0; i < names.length; i++) {
			fieldStr[2] = names[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}
		mc = new MemoriCommand(MemoriCommandType.SORT, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> sorted = calendar.getEvents();
		boolean sortStatus = true;

		for (int i = 0; i < sorted.size() - 1; i++) {
			String first = sorted.get(i).getName();
			String second = sorted.get(i + 1).getName();
			if (first.compareToIgnoreCase(second) > 0) {
				sortStatus = false;
				break;
			}
		}
		assertTrue(sortStatus);
	}
	@Test
	public void testExecuteSortLocation() {
		initialize();
		String[] fieldStr = new String[] { "name", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		Boolean[] memoriField = new Boolean[] { true, false, false, true, false };
		MemoriCommand mc;
		String[] names = new String[] { "5", "name", "123name", "HELLO", "hello", "blah" };
		for (int i = 0; i < names.length; i++) {
			fieldStr[1] = names[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}
		mc = new MemoriCommand(MemoriCommandType.SORT, memoriField);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> sorted = calendar.getEvents();
		boolean sortStatus = true;

		for (int i = 0; i < sorted.size() - 1; i++) {
			String first = sorted.get(i).getLocation();
			String second = sorted.get(i + 1).getDescription();
			if (first.compareToIgnoreCase(second) > 0) {
				sortStatus = false;
				break;
			}
		}
		assertTrue(sortStatus);
	}

	@Test
	public void testExecuteSearchKeyWord() {
		initialize();
		String[] fieldStr = new String[] { "", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		MemoriCommand mc;
		String[] names = new String[] { "5", "name", "123name", "HELLO", "hello", "blah" };
		for (int i = 0; i < names.length; i++) {
			fieldStr[0] = names[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}

		fieldStr[0] = "name";
		mc = new MemoriCommand(MemoriCommandType.SEARCH, start, end, fieldStr);
		calendar.execute(mc, google);
		calendar.display();
		ArrayList<MemoriEvent> searchedList = calendar.getSearch();
		assertTrue(searchedList.size() == 2);
	}
	
	@Test
	public void testExecuteSearchDates() {
		initialize();
		String[] fieldStr = new String[] { "", "testDescribe", "testPlace" };
		Date start = new Date();
		Date end = new Date();
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		Date[] endDates = new Date[] { new Date(), new Date(222222222222L), new Date(3333333333333L),
				new Date(0), new Date(888888888L) };
		for (int i = 0; i < endDates.length; i++) {
			start = endDates[i];
			end = endDates[i];
			mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
			calendar.execute(mc, google);
		}

		start = new Date(888888888L);
		end = new Date(222222222222L);
		mc = new MemoriCommand(MemoriCommandType.SEARCH, start, end, fieldStr);
		calendar.execute(mc, google);
		calendar.display();
		ArrayList<MemoriEvent> searchedList = calendar.getSearch();
		assertTrue(searchedList.size() == 2);
	}
	
	@Test
	public void testExecuteToggleComplete() {
		initialize();
		String[] fieldStr = new String[] { "test", "testDescribe", "testPlace" };
		Date start = null;
		Date end = null;
		MemoriCommand mc = new MemoriCommand(MemoriCommandType.ADD, start, end, fieldStr);
		ArrayList<Integer> indexes = new ArrayList<Integer>();
		for (int i = 0; i < 10; i++) {
			calendar.execute(mc, google);
		}
		indexes.add(3);
		indexes.add(2);
		indexes.add(5);
		indexes.add(7);
		ArrayList<MemoriEvent> main = calendar.getEvents();
		MemoriEvent latestEvent = main.get(main.size() - 1);
		calendar.display();
		mc = new MemoriCommand(MemoriCommandType.COMPLETE, indexes);
		calendar.execute(mc, google);
		ArrayList<MemoriEvent> searchedList = calendar.getSearch();
		assertTrue(searchedList.get(2).getComplete());
		assertTrue(searchedList.get(1).getComplete());
		assertTrue(searchedList.get(4).getComplete());
		assertTrue(searchedList.get(6).getComplete());
	}

}
```
###### ./logic/MemoriUndoManager.java
``` java
package memori.logic;

import java.util.ArrayList;
import java.util.Stack;

public class MemoriUndoManager {
	private Stack<ArrayList<MemoriEvent>> undoStack;

	public MemoriUndoManager() {
		undoStack = new Stack<ArrayList<MemoriEvent>>();
	}
	

	public ArrayList<MemoriEvent> undo(){
		if(!undoStack.empty()){
			ArrayList<MemoriEvent> temp = undoStack.pop();
			return temp;
		}
		else
			return null;
	}
	
	
	
	public void addToUndo(ArrayList<MemoriEvent> events){
		ArrayList<MemoriEvent> copy = copyEventsArr(events);
		undoStack.add(copy);
	
	}
	

	
	private ArrayList<MemoriEvent> copyEventsArr(ArrayList<MemoriEvent> toCopy){
		ArrayList<MemoriEvent> theCopy = new ArrayList<MemoriEvent>();
		for(int i=0;i<toCopy.size();i++){
			MemoriEvent current = toCopy.get(i);
			MemoriEvent toAdd = new MemoriEvent();
			toAdd.replace(current);
			toAdd.setExternalCalId(current.getExternalCalId());
			toAdd.setInternalCalId(current.getInternalId());
			toAdd.setComplete(current.getComplete());
			theCopy.add(toAdd);
		}
		return theCopy;
	}

}
```
###### ./Memori.java
``` java
package memori;

import memori.Storage.MemoriSettings;
import memori.Storage.MemoriStorage;
import memori.googleSync.MemoriSync;
import memori.logic.MemoriCalendar;
import memori.logic.MemoriLock;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;
import memori.parsers.MemoriParser;
import memori.ui.MemoriUI;

public class Memori {
	/** UI Component */
	private MemoriUI ui = new MemoriUI();

	/** Storage Component */
	private MemoriStorage st = MemoriStorage.getInstance();

	/** Storage Component */
	private MemoriCalendar memoriCalendar;

	/** Parser Component */
	private MemoriParser memoriParser = new MemoriParser();

	/** Settings Component */
	private MemoriSettings memoriSettings = MemoriSettings.getInstance();

	/** Sync Component */
	private MemoriSync googleSync = new MemoriSync();

	/** Messages */
	private static final String WELCOME_MSG = " ____    ____  ________  ____    ____   ___   _______     _____  "
			+ "\n|_   \\  /   _||_   __  ||_   \\  /   _|.'   `.|_   __ \\   |_   _|"
			+ "\n  |   \\/   |    | |_ \\_|  |   \\/   | /  .-.  \\ | |__) |    | |"
			+ "\n  | |\\  /| |    |  _| _   | |\\  /| | | |   | | |  __ /     | |"
			+ "\n  | |_\\/_| |_  _| |__/ | _| |_\\/_| |_\\  `-'  /_| |  \\ \\_  _| |_"
			+ "\n|_____||_____||________||_____||_____|`.___.'|____| |___||_____| \n\n";

	private static final String COMMAND_PROMPT = "Command:";

	public void run() {
		setup();
		executeCommands();
	}

	/** Sets up Memori by initializing the components */
	public void setup() {
		Thread memoriLockThread = new Thread(new MemoriLock());
		memoriLockThread.start();
		memoriSettings = st.loadSettings();
		memoriCalendar = st.loadCalendar();
		if (memoriCalendar == null) {
			memoriCalendar = new MemoriCalendar();
		}
		ui.clearConsole();
		ui.displayToUser(googleSync.initialize(memoriCalendar));
		memoriCalendar.initialize();
		st.saveCalendar(memoriCalendar);
		ui.displayToUser(WELCOME_MSG);
		ui.displayToUser(memoriCalendar.display());
	}
	
	/** Takes in input from the user and executes them */
	public void executeCommands() {
		while (true) {
			ui.displayToUser(COMMAND_PROMPT);
			String userInput = ui.takeInput();
			MemoriCommand command = memoriParser.parse(userInput);
			checkExit(command.getType());
			String ack = memoriCalendar.execute(command, googleSync);
			ui.clearConsole();
			ui.displayToUser(WELCOME_MSG);
			ui.displayToUser(memoriCalendar.display());
			ui.displayToUser(ack);
			st.saveCalendar(memoriCalendar);
		}
	}

	private void checkExit(MemoriCommandType type) {
		if (type == MemoriCommandType.EXIT)
			System.exit(0);
	}

	public static void main(String[] args) {
		Memori memori = new Memori();
		memori.run();
	}
}
```
###### ./MemoriTest.java
``` java
package memori;

import static org.junit.Assert.assertTrue;

import java.io.IOException;

import org.junit.Test;

import com.google.api.services.calendar.Calendar;

import memori.googleSync.GCalConnect;
import memori.googleSync.MemoriSync;
import memori.logic.MemoriCalendar;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriParser;
import memori.ui.MemoriUI;

public class MemoriTest {
	private static final String MESSAGE_ADD = "Event Added.\n";
	private static final String MESSAGE_DELETE = "Event Deleted.\n";
	private static final String MESSAGE_NO_RESULTS = "No results found\n";
	private static final String MESSAGE_READ = "Reading: %1$d \n";
	private static final String MESSAGE_SORT = "Sorted.\n";
	private static final String MESSAGE_UPDATE = "Updated Event %1$d \n";
	private static final String MESSAGE_INVALID_INDEX = "Line index does not exists.\n";
	private static final String MESSAGE_INVALID_INPUT_NAME = "Invalid input. Name should not be empty. \n";
	private static final String MESSAGE_INVALID_INPUT_START = "Invalid input. New start date should not be later"
			+ " than original end date. \n";
	private static final String MESSAGE_INVALID_INPUT_END = "Invalid input. New end date should not be earlier"
			+ " than original start date. \n";
	private static final String MESSAGE_INVALID_INPUT_GENERAL = "Invalid input. \n";
	private static final String MESSAGE_COMPLETE = "Tasks have been marked complete. \n";
	private static final String MESSAGE_OPEN = "Tasks have been reopened\n";
	private static final String MESSAGE_EMPTYFILE = "File is Empty.\n";
	private static final String MESSAGE_CHANGE_SEARCH = "Your search conditions has been changed.\n";
	private static final String MESSAGE_UNDO = "Your changes have been undone.\n";
	private static final String MESSAGE_UNDO_INVALID = "You cannot undo anymore.\n";
	
	private static final String NAME_HEADER = "Name:";
	private static final String START_HEADER = "Start: ";
	private static final String END_HEADER = "End: ";
	private static final String LOCATION_HEADER = "Location:";
	private static final String DESCRIPTION_HEADER = "Description:";

	private MemoriCalendar calendar;
	private MemoriSync sync;
	private MemoriParser parser = new MemoriParser();
	private MemoriUI ui = new MemoriUI();
	private Calendar service = GCalConnect.getCalendarService();

	public void initialize() {
		ErrorSuppressor.supress();
		try {
			service.calendars().clear("primary").execute();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		calendar = new MemoriCalendar();
		sync = new MemoriSync();
		calendar.initialize();
		sync.initialize(calendar);
		calendar.display();
	}

	@Test
	public void testUndoFail() {
		initialize();
		String userInput = "undo";
		MemoriCommand cmd = parser.parse(userInput);
		String response = "";
		response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_UNDO_INVALID));
	}

	@Test
	public void testAddFloat() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_ADD));
	}
	@Test
	public void testAddEvent() {
		initialize();
		String userInput = "add -n test -s today -e tomorrow";
		MemoriCommand cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_ADD));
	}
	
	@Test
	public void testAddDeadline() {
		initialize();
		String userInput = "add -n test -e tomorrow";
		MemoriCommand cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_ADD));
	}
	
	@Test
	public void testAddNoEnd() {
		initialize();
		String userInput = "add -n test -s tomorrow";
		MemoriCommand cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_ADD));
	}
	
	@Test
	public void testAddwithAllFields() {
		initialize();
		String userInput = "add -n test -s tomorrow -e the next day -d description - l location";
		MemoriCommand cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_ADD));
	}


	@Test
	public void testDeleteOne() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		calendar.display();
		userInput = "delete 1";
		cmd = parser.parse(userInput);
		response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_DELETE));
	}

	@Test
	public void testDeleteMultiple() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		for (int i = 0; i < 10; i++) {
			calendar.execute(cmd, sync);
		}
		calendar.display();
		userInput = "delete 1-10";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_DELETE));
	}

	@Test
	public void testComplete1() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		calendar.execute(cmd, sync);
		calendar.display();
		userInput = "complete 1";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_COMPLETE));
	}

	@Test
	public void testCompleteMultiple() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		for (int i = 0; i < 10; i++) {
			calendar.execute(cmd, sync);
		}
		calendar.display();
		userInput = "complete 1-10";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		assertTrue(response.equals(MESSAGE_COMPLETE));
	}
	
	@Test
	public void testUpdateName() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		calendar.execute(cmd,sync);
		calendar.display();
		userInput = "update 1 -n update";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		System.out.println(response);
		assertTrue(response.contains(String.format(MESSAGE_UPDATE, 1)));
		assertTrue(response.contains(NAME_HEADER));
	}
	
	@Test
	public void testUpdateStart() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		calendar.execute(cmd,sync);
		calendar.display();
		userInput = "update 1 -s today";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		System.out.println(response);
		assertTrue(response.contains(String.format(MESSAGE_UPDATE, 1)));
		assertTrue(response.contains(START_HEADER));
	}
	
	@Test
	public void testUpdateEnd() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		calendar.execute(cmd,sync);
		calendar.display();
		userInput = "update 1 -e today";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		System.out.println(response);
		assertTrue(response.contains(String.format(MESSAGE_UPDATE, 1)));
		assertTrue(response.contains(END_HEADER));
	}
	
	@Test
	public void testUpdateStartAndEnd() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		calendar.execute(cmd,sync);
		calendar.display();
		userInput = "update 1 -s today -e tomorrow";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		System.out.println(response);
		assertTrue(response.contains(String.format(MESSAGE_UPDATE, 1)));
		assertTrue(response.contains(START_HEADER));
		assertTrue(response.contains(END_HEADER));
	}
	
	@Test
	public void testUpdateAllFields() {
		initialize();
		String userInput = "add -n test";
		MemoriCommand cmd = parser.parse(userInput);
		calendar.execute(cmd,sync);
		calendar.display();
		userInput = "update 1 -n updated -s today -e tomorrow -d description -l location";
		cmd = parser.parse(userInput);
		String response = calendar.execute(cmd, sync);
		System.out.println(response);
		assertTrue(response.contains(String.format(MESSAGE_UPDATE, 1)));
		assertTrue(response.contains(NAME_HEADER));
		assertTrue(response.contains(START_HEADER));
		assertTrue(response.contains(END_HEADER));
		assertTrue(response.contains(LOCATION_HEADER));
		assertTrue(response.contains(DESCRIPTION_HEADER));
	}



}
```
###### ./TestSuite.java
``` java
package memori;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

import memori.Storage.SettingsTest;
import memori.Storage.StorageTest;
import memori.googleSync.GoogleCRUDTest;
import memori.googleSync.MemoriSyncTest;
import memori.logic.MemoriCalendarTest;
import memori.parsers.parserTesting.AddParserTest;
import memori.parsers.parserTesting.IndexesParserTest;
import memori.parsers.parserTesting.MemoriParserTest;
import memori.parsers.parserTesting.SearchParserTest;
import memori.parsers.parserTesting.SortParserTest;
import memori.parsers.parserTesting.UpdateParserTest;
@RunWith(Suite.class)
@Suite.SuiteClasses({
   MemoriTest.class,
   MemoriCalendarTest.class,
   GoogleCRUDTest.class,
   MemoriSyncTest.class,
   AddParserTest.class,
   IndexesParserTest.class,
   MemoriParserTest.class,
   SearchParserTest.class,
   SortParserTest.class,
   UpdateParserTest.class,
   StorageTest.class,
   SettingsTest.class,
   
})
public class TestSuite {   
}  
```
###### ./ui/MemoriUI.java
``` java
package memori.ui;

import java.util.Scanner;

public class MemoriUI {
	private static final int CUT_OFF_LENGTH = 91;
	private static final char NEW_LINE = '\n';
	private Scanner sc = new Scanner(System.in);
	
	
	public void displayToUser(String msg){
		String output = "";
		int numCharInLine = 0;
		for(int i = 0;i < msg.length();i++, numCharInLine++){
			if( msg.charAt(i) == NEW_LINE){
				numCharInLine = 0;
			}
			if(numCharInLine == CUT_OFF_LENGTH){
				output += NEW_LINE;
			}
			output += msg.charAt(i);
		}
		System.out.print(output);
	}

	public String takeInput() {
		return sc.nextLine();
	}

	public void clearConsole() {
		for(int i=0;i< 50;i++){
			System.out.println();
		}
	}
	
}
```
