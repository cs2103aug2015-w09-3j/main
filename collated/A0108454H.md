# A0108454H
###### ./parsers/AddParser.java
``` java
package memori.parsers;

import java.util.Date;

public class AddParser extends FieldsParser {
	private static final String INVALID_NAME_MESSAGE = "Oops,please enter the name of the event"+"\n";
	private static final String INVALID_DATE_MESSAGE = "Oops,invalid date format.Please try again"+"\n";
	private static final String INVALID_LOCATION_MESSAGE = "Oops,invalid location format.Please try again"+"\n";
	private static final String INVALID_DESCRIPTION_MESSAGE = "Oops,invalid description format.Please try again"+"\n";

	public AddParser() {
		// TODO Auto-generated constructor stub
		init();
	}

	@Override
	public MemoriCommand parse(MemoriCommandType cmdType, String cmdFields) {
		// TODO Auto-generated method stub
		
		extractFields(cmdFields);
		String[] stringFields = extractStrings();
		Date[] startEnd = extractDates();
		UpdateFilledFields();
		
		//*added if there is no name for the add event
		
		if(stringFields[0].equals("")||(cmdFields.length()==0)){
			
			return new MemoriCommand(INVALID_NAME_MESSAGE);
		
		//*if the user indicates he wants to enter a start date but there is no start date.	
		}else if((FilledFields[START_INDEX]==true)&&startEnd[0]==null){	
			
			return new MemoriCommand(INVALID_DATE_MESSAGE);
		//*if the user indicates he wants to enter a end date but there is no end date 
		}else if((FilledFields[END_INDEX]==true)&&(startEnd[1]==null)){
			
			return new MemoriCommand(INVALID_DATE_MESSAGE);
		//*if the user indicates he wants to enter a location but there is no location
		}else if((FilledFields[LOCATION_INDEX]==true)&&(stringFields[1].equals(""))){
			
			return new MemoriCommand(INVALID_LOCATION_MESSAGE);
		//if the users indicates he wants to enter a description but there is no description
		}else if((FilledFields[DESCRIPTION_INDEX]==true)&&(stringFields[2].equals(""))){
			
			return new MemoriCommand(INVALID_DESCRIPTION_MESSAGE);
		
		}
		
		return new MemoriCommand(cmdType,startEnd[0],startEnd[1],stringFields);
			
	}
	
}
```
###### ./parsers/DateParser.java
``` java
package memori.parsers;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import memori.ErrorSuppressor;
import memori.Storage.MemoriSettings;

public class DateParser {
	private static boolean invertMonth = MemoriSettings.getInstance().getInvertMonth();
	public static final String[] regex = { "/", "-" };
	private static final int STANDARD_HOUR = 9;
	private static final int STANDARD_MIN = 0;
	private static final int STANDARD_SEC = 0;
	private static final int START_HOUR = 0;
	private static final int START_MIN = 0;
	private static final int START_SEC = 0;
	private static final int END_HOUR = 23;
	private static final int END_MIN = 59;
	private static final int END_SEC = 59;
	private static final String EXPLICIT_TIME = "EXPLICIT_TIME";
	private static final String RELATIVE_TIME = "RELATIVE_TIME";

	public static void setInvert(boolean status) {
		invertMonth = status;
	}
	/**
	 * this method get a date in a form of string
	 * if its a relative date , set hour to 9 , min to 0 ,sec to 0
	 * then return a date object
	 * @param dateToParse
	 * @return
	 */
	public static Date parseDate(String dateToParse) {
		if (invertMonth) {
			dateToParse = reverseMonth(dateToParse);
		}
		ErrorSuppressor.supress();
		Parser parser = new Parser();
		List<Date> dateList = new ArrayList<Date>();
		List<DateGroup> groups = parser.parse(dateToParse);
		ErrorSuppressor.unsupress();
		if (!groups.isEmpty()) {

			DateGroup dg = groups.get(0);
			String syntaxTree = dg.getSyntaxTree().toStringTree();
			dateList.addAll(dg.getDates());
			if ((!syntaxTree.contains(EXPLICIT_TIME)) && 
					(!syntaxTree.contains(RELATIVE_TIME))) {
				return dateForRelativeDate(dateList,
						STANDARD_HOUR,STANDARD_MIN,STANDARD_SEC);
			}

			return dateList.get(0);
		}
		return null;
	}

	
	/**
	 * this method gets the start date and the end date of search in a string array 
	 * if its start replace hrs, mins, second to 0hrs 0mins 0 sec
	 * if its a end replace hrs, mins ,second to 23hrs 59mins 59 mins
	 * then return both start and end in a Date arrray
	 * @param searchDate
	 * @return
	 */
	public static Date[] parseSearchDate(String[] searchDate){
		Date[] searchDates = new Date[2];
		String dateToParse;
		for(int i = 0;i < searchDate.length; i++){
			if (invertMonth) {
				 dateToParse = reverseMonth(searchDate[i]);
			}else{
				dateToParse = searchDate[i];
			}
			ErrorSuppressor.supress();
			Parser parser = new Parser();
			
			List<Date> dateList = new ArrayList<Date>();
			List<DateGroup> groups = parser.parse(dateToParse);
			ErrorSuppressor.unsupress();
			if (!groups.isEmpty()) {

				DateGroup dg = groups.get(0);
				String syntaxTree = dg.getSyntaxTree().toStringTree();
				dateList.addAll(dg.getDates());
				if ((!syntaxTree.contains(EXPLICIT_TIME)) 
						&& (!syntaxTree.contains(RELATIVE_TIME))) {
					if(i==0){
						searchDates[i] = dateForRelativeDate(dateList,
								START_HOUR,START_MIN,START_SEC);
					}else{
						searchDates[i] = dateForRelativeDate(dateList,
								END_HOUR,END_MIN,END_SEC);
					}
				}else{
					searchDates[i] = dateList.get(0);
				}	
			}else{
				searchDates[i] = null;
			}	
		}
		return searchDates;
	}
	private static String reverseMonth(String dateToParse) {
		String[] splitted = {};
		StringBuilder inverted = new StringBuilder();
		for (String rx : regex) {
			splitted = dateToParse.split(rx);
			if (splitted.length == 2) {
				inverted.append(splitted[1]);
				inverted.append(rx);
				inverted.append(splitted[0]);
				return inverted.toString();
			} else if (splitted.length == 3) {
				try {
					if (Integer.parseInt(splitted[0]) <= 31) {
						inverted.append(splitted[1]);
						inverted.append(rx);
						inverted.append(splitted[0]);
						inverted.append(rx);
						inverted.append(splitted[2]);
						return inverted.toString();
					}
				} catch (NumberFormatException e) {
					return dateToParse;
				}
			}

		}

		return dateToParse;
	}
	/**
	 *This method will set the hours , min and sec if the user 
	 *enter a relative date 
	 *then return a date object 
	 * @param dateList
	 * @param HOUR
	 * @param MIN
	 * @param SEC
	 * @return
	 */
	private static Date dateForRelativeDate(List<Date> dateList,int HOUR
			,int MIN,int SEC) {
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(dateList.get(0));
		calendar.set(Calendar.HOUR_OF_DAY, HOUR);
		calendar.set(Calendar.MINUTE, MIN);
		calendar.set(Calendar.SECOND, SEC);
		return calendar.getTime();
	}
}
```
###### ./parsers/Field.java
``` java
package memori.parsers;

public class Field implements Comparable<Field>{
	private String name;
	private String content;
	private int indexInString;
	
	public String getName(){
		return name;
	}
	
	public String getContent(){
		return content;
	}
	
	public int getIndexInString(){
		return  indexInString;
	}
	
	public void setContent(String content){
		this.content = content;
	}
	
	public void setIndexInString(int index){
		this.indexInString = index;
	}
	
	
	public Field(String name){
		this.name = name;
		content = "";
		indexInString = -1;
	}

	@Override
	public int compareTo(Field other) {
		return this.indexInString - other.getIndexInString();
	}
	
	@Override
	public String toString(){
		return name + content;
	}
}
```
###### ./parsers/FieldsParser.java
``` java
package memori.parsers;

import java.util.Arrays;
import java.util.Date;

public abstract class FieldsParser {
	//** change from private to protected
	protected static final String[] FIELD_IDENTIFIERS = {"-n","-s","-e","-l","-d"};
	public static final int NAME_INDEX = 0;
	public static final int START_INDEX = 1;
	public static final int END_INDEX = 2;
	public static final int LOCATION_INDEX = 3;
	public static final int DESCRIPTION_INDEX = 4;
	
	
	protected Boolean[] FilledFields = new Boolean[FIELD_IDENTIFIERS.length];
	protected Field[] fields= new Field[FIELD_IDENTIFIERS.length];
	public abstract MemoriCommand parse(MemoriCommandType cmdType, String fields);
	
	protected void init(){
		for(int i=0;i<fields.length;i++){
			FilledFields[i] = false;
			fields[i] = new Field(FIELD_IDENTIFIERS[i]);
		}
	}
	/**
	 * This method first check the which field is stored in the Field array
	 * by comparing with the FieldIdentifiers,
	 * the content will be stored in string fields
	 * @return
	 */
	protected String[] extractStrings(){
		String[] strFields = new String[MemoriCommand.NUM_STRING_FIELDS];
		
		for(Field f: fields){
			if(f.getName().equals(FIELD_IDENTIFIERS[NAME_INDEX])){
				strFields[MemoriCommand.NAME_INDEX] = f.getContent();
			}
			else if(f.getName().equals(FIELD_IDENTIFIERS[LOCATION_INDEX])){
				strFields[MemoriCommand.LOCATION_INDEX] = f.getContent();

			}
			else if(f.getName().equals(FIELD_IDENTIFIERS[DESCRIPTION_INDEX])){
				strFields[MemoriCommand.DESCRIPTION_INDEX] = f.getContent();

			}
		
		}
		return strFields;
	}
	/**
	 * This method will first indicate which is the start date and the 
	 * end date. It will then parse the date to DateParser to get an date object 
	 * @return
	 */
	protected Date[] extractDates(){
		Date[] startEnd = new Date[2];
		for(Field f: fields){
			if(f.getName().equals(FIELD_IDENTIFIERS[START_INDEX])){
				startEnd[0] = DateParser.parseDate(f.getContent());
				
			}
			else if(f.getName().equals(FIELD_IDENTIFIERS[END_INDEX])){
				startEnd[1] = DateParser.parseDate(f.getContent());
			
			}
			
		}
		if(startEnd[0]!= null && startEnd[1] != null ){
			Arrays.sort(startEnd);
		}
		return  startEnd;
	}
	/**
	 * this method find the start and the end of the search dates
	 * pass it to dateparser and process
	 * @return
	 */
	protected Date[] extractSearchDates(){
		
		String[] startEnd = new String[2];
		
		for(Field f: fields){
			if(f.getName().equals(FIELD_IDENTIFIERS[START_INDEX])){
				startEnd[0] = f.getContent();
			}
			else if(f.getName().equals(FIELD_IDENTIFIERS[END_INDEX])){
				startEnd[1] = f.getContent();
			}
			
		}
	
		return DateParser.parseSearchDate(startEnd);
	}
	/**
	 *This has method will extract all the indexes of the position
	 *of the indicated fields in the userInput which memori allows 
	 *Then it will get all the information of the respective fields
	 *
	 * @param toExtract
	 */
	protected void extractFields(String toExtract){
		int i =0;
		for(; i < fields.length ; i++ ){
			fields[i].setIndexInString(toExtract.indexOf(FIELD_IDENTIFIERS[i]));
		}
		Arrays.sort(fields);
		for(i=0; i < fields.length ; i++ ){
			if(fields[i].getIndexInString() < 0)
				continue;
			int start = fields[i].getIndexInString() + fields[i].getName().length();
			int end;
			if(i< fields.length - 1){
				end = fields[i+1].getIndexInString();
			}
			else{
				end = toExtract.length();
			}
			fields[i].setContent(toExtract.substring(start,end).trim());
		}
	}
	/**
	 *update which are the Fields the user has indicated
	 * 
	 */
	public void UpdateFilledFields(){
		
		for(int i = 0;i < fields.length;i++){
			
			if(fields[i].getIndexInString()!=-1){
				if(fields[i].getName().equals(FIELD_IDENTIFIERS[NAME_INDEX])){
					FilledFields[NAME_INDEX]=true;
				}
				if(fields[i].getName().equals(FIELD_IDENTIFIERS[START_INDEX])){
					FilledFields[START_INDEX]=true;
				}
				if(fields[i].getName().equals(FIELD_IDENTIFIERS[END_INDEX])){
					FilledFields[END_INDEX] = true;
				}
				if(fields[i].getName().equals(FIELD_IDENTIFIERS[LOCATION_INDEX])){
					FilledFields[LOCATION_INDEX] = true;
				}
				if(fields[i].getName().equals(FIELD_IDENTIFIERS[DESCRIPTION_INDEX])){
					FilledFields[DESCRIPTION_INDEX] = true;
				}
			}
		}
	}
	
	//for testing
	public Boolean[] returnFilledFields(){
		return FilledFields;
	}
	public Field[] fields(){
		return fields;
	}
}

```
###### ./parsers/IndexesParser.java
``` java
package memori.parsers;

import java.util.ArrayList;


public class IndexesParser extends FieldsParser {
	public static final String INVALID_MESSAGE = "Oops, index ares not available,please try again"+"\n";
    private static final String RANGE_SPLITTER = "-";
    private static ArrayList<Integer> INDEXES = new ArrayList<Integer>();
    public IndexesParser() {
		// TODO Auto-generated constructor stub
		init();
	}

	@Override
	public MemoriCommand parse(MemoriCommandType cmdType, String cmdFields) {
		INDEXES = new ArrayList<Integer>();
		try{
			if(!cmdFields.contains(RANGE_SPLITTER)){
				splitIndividualIndex(cmdFields);
				return new MemoriCommand(cmdType,INDEXES);
			}else{
				addRange(cmdFields);
				return new MemoriCommand(cmdType,INDEXES);
			}
			
		}catch(NumberFormatException e){
			return new MemoriCommand(INVALID_MESSAGE);
		}catch(wrongIndexFormat e){
			return new MemoriCommand(INVALID_MESSAGE);
		}
	}	
	private void splitIndividualIndex(String cmdFields){
		
		for(int index = 0; index <cmdFields.length();index++){
			if(cmdFields.charAt(index)!=' '){
				int nextSpace = findNextSpace(index,cmdFields);
				int indexToDelete = Integer.parseInt(cmdFields.substring(index,nextSpace).replaceAll(" ",""));
				if(!INDEXES.contains(indexToDelete)){
					INDEXES.add(indexToDelete);
				}
				index = nextSpace;
			}
		}
	}
	private int findNextSpace(int index,String cmdFields){
		for(;index<cmdFields.length();index++){
			if(cmdFields.charAt(index)==' '){
				return index;
			}
		}
		return index;
	}
	private void addRange(String cmdFields) throws wrongIndexFormat{
		int rangeIndex1;
		int rangeIndex2;
		int ExpectedNoOfNumbers = 2;
		String[] split = cmdFields.split(RANGE_SPLITTER);
		if((cmdFields.length() - cmdFields.replaceAll(RANGE_SPLITTER,"").length())>1){
			throw new wrongIndexFormat();
		}else if(split.length!=ExpectedNoOfNumbers){
			throw new wrongIndexFormat();
		}else{
			rangeIndex1 = Integer.parseInt(split[0].trim());
			rangeIndex2 = Integer.parseInt(split[1].trim());
			addToIndexes(rangeIndex1,rangeIndex2);
		}
	}

	private void addToIndexes(int rangeIndex1,int rangeIndex2){
		int upper;
		int lower;
		if(rangeIndex1 > rangeIndex2){
			upper = rangeIndex1;
			lower = rangeIndex2;
			
		}else{
			upper = rangeIndex2;
			lower = rangeIndex1;
		
		}
		for(;lower<upper+1;lower++){
			INDEXES.add(lower);
		}
	}
	
}
```
###### ./parsers/InvalidParser.java
``` java
package memori.parsers;

// handle invalid
public class InvalidParser extends FieldsParser{
	public static final String INVALID_MESSAGE = "Oops, the command you have entered is not available."
			+ "Please try again"+"\n";
	@Override
	public MemoriCommand parse(MemoriCommandType cmdType, String fields) {
		
		return new MemoriCommand(INVALID_MESSAGE);
	}

}

```
###### ./parsers/MemoriCommand.java
``` java
package memori.parsers;

import java.util.ArrayList;
import java.util.Date;

public class MemoriCommand {
	private MemoriCommandType commandType;
	private String[] commandArgs;
	private Boolean[] memoriFields;
	private Date start;
	private Date end;
	private int index = 0;
	private ArrayList<Integer> indexes;
	private String invalidMessage;
	//jayden added more indexs
	public static final int NAME_INDEX = 0;
	public static final int LOCATION_INDEX = 1;
	public static final int DESCRIPTION_INDEX = 2;
	public static final int NUM_STRING_FIELDS = 3;
	
	
	public MemoriCommand(MemoriCommandType commandType,Date start,Date end,String[] commandArgs){
		this.commandType = commandType;
		this.start = start;
		this.end = end;
		this.commandArgs = commandArgs;
	}
	public MemoriCommand(MemoriCommandType cmdType){
		commandType = cmdType;
	}
	public MemoriCommand(MemoriCommandType commandType,Date start
			,Date end,String[] commandArgs,int index,Boolean[] memoriFields){
		this.commandType = commandType;
		this.start = start;
		this.end = end;
		this.commandArgs = commandArgs;
		this.index = index;
		this.memoriFields = memoriFields;
	}
	public MemoriCommand(MemoriCommandType commandType,ArrayList<Integer> indexes){
		this.commandType = commandType;
		this.indexes = indexes;
	}
	public MemoriCommand(String invalidMessage){
		this.commandType = MemoriCommandType.INVALID;
		this.invalidMessage = invalidMessage;
	}
	//new change, for sort
	public MemoriCommand(MemoriCommandType commandType,Boolean[] memoriFields){
		this.commandType = commandType;
		this.memoriFields = memoriFields;
	}
	public MemoriCommandType getType(){
		return commandType;
	}
	
	public Date getStart(){
		return start;
	}
	
	public Date getEnd(){
		return end;
	}
	
	public String getName(){
		return commandArgs[NAME_INDEX];
	}
	public String[] getCommandArgs(){
		return commandArgs;
	}
	public String getDescription(){
		return commandArgs[DESCRIPTION_INDEX];
	}
	public String getLocation(){
		return commandArgs[LOCATION_INDEX];
	}
	public int getIndex() {
		return index;
	}

	public ArrayList<Integer> getIndexes() {
		return indexes;
	}
	public Boolean[] getMemoriField(){
		return memoriFields;
	}
	public String getInvalidMessage(){
		return invalidMessage; 
	}


}
```
###### ./parsers/MemoriCommandType.java
``` java
package memori.parsers;

public enum MemoriCommandType {
	ADD, UPDATE, DELETE, EXIT, INVALID, READ, SORT, SEARCH, CLEAR, UNDO, COMPLETE, OPEN
}
```
###### ./parsers/MemoriParser.java
``` java
package memori.parsers;

public class MemoriParser {
	
	// commandConfig Array indexes
	private static final int COMMAND_TYPE = 0;
	private static final int FIELDS = 1;
	private static final String SYSTEM_FIELD = "system";

	private String[] commandConfig = new String[2];
	public static final String INVALID_MESSAGE = "Oops you entered an invalid command, please try again."+"\n";	
	
	//The main parse method
	public MemoriCommand parse(String userInput) {
		String[] commandConfig = seperateCommand(userInput);
		MemoriCommandType cmdType = determineCommandType(commandConfig[COMMAND_TYPE]);
		FieldsParser fp = createFieldsParser(cmdType);
		return executeParse(userInput, commandConfig, cmdType, fp);	
	}
	/**
	 * this method will execute the parse function.
	 * 
	 * @param userInput
	 * @param commandConfig
	 * @param cmdType
	 * @param fp
	 * @return
	 */
	private MemoriCommand executeParse(String userInput,
			String[] commandConfig, MemoriCommandType cmdType, FieldsParser fp) {
	
		if((cmdType==MemoriCommandType.EXIT)
				||(cmdType==MemoriCommandType.UNDO)){
			
			return fp.parse(cmdType,SYSTEM_FIELD);
		
		}else if(commandConfig.length==1||userInput.length()==0){
			
			return new MemoriCommand(INVALID_MESSAGE);
		
		}else{
			
			return fp.parse(cmdType, commandConfig[FIELDS]);
		}
	}
	/**
	 * This method will determine which type of parser to handle the user input
	 * base on user the commandType
	 * @param cmdType
	 * @return
	 */
	private FieldsParser createFieldsParser(MemoriCommandType cmdType){
	
		switch(cmdType){
		case ADD:		
			return new AddParser();
		case UPDATE:
			return new UpdateParser();
		case DELETE:
			return new IndexesParser();
		case READ:
			return new IndexesParser();
		case SEARCH:
			return new SearchParser();
		case SORT:
			return new SortParser();
		case COMPLETE:
		case OPEN:
			return new IndexesParser();
		case UNDO:
			return new SystemParser();
		case EXIT:
			return new SystemParser();
		default:
			return new InvalidParser();
		}
	}
	/**
	 * This function splits the users input to a commandType in a form of string
	 * and the details the user followed with the commmand Type
	 * @param userInput
	 * @return 
	 */
	private static String[] seperateCommand(String userInput) {
		return userInput.split(" ",2);
	}
	/**
	 * This function determines users command type using swith cases and return 
	 * the users commandType 
	 * @param commandTypeString
	 * @return MemoriCommandType
	 */
	private MemoriCommandType determineCommandType(String commandTypeString){
		commandTypeString = commandTypeString.toUpperCase();
		switch (commandTypeString) {
        case "ADD":
            return MemoriCommandType.ADD;
        case "UPDATE":
        	 return MemoriCommandType.UPDATE;
        case "DELETE":
             return MemoriCommandType.DELETE;
        case "READ":
        	 return MemoriCommandType.READ;
        case "SEARCH":
        	return MemoriCommandType.SEARCH;
        case "SORT":
        	return MemoriCommandType.SORT;
        case "COMPLETE":
        	return MemoriCommandType.COMPLETE;
        case "OPEN":
        	return MemoriCommandType.OPEN;
        case "UNDO":
        	return MemoriCommandType.UNDO;
        case "EXIT":
        	return MemoriCommandType.EXIT;
     
        default:
        	 return MemoriCommandType.INVALID;
		}
	}
}
```
###### ./parsers/parserTesting/AddParserTest.java
``` java
package memori.parsers.parserTesting;
import java.text.SimpleDateFormat;

import static org.junit.Assert.*;

import java.util.Date;

import memori.parsers.AddParser;
import memori.parsers.DateParser;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;

import org.junit.Test;

public class AddParserTest {
	public static final String DATE_FORMAT = "dd MMM yyyy HH:mm E";
	private static final SimpleDateFormat DATE_FORMATTER = new SimpleDateFormat(DATE_FORMAT);
	@Test
	public final void add1() {
		MemoriCommandType add = MemoriCommandType.ADD;
		MemoriCommand expected = new MemoriCommand("");
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-s");
		
		assertTrue(compareTo(result, expected));
	}

	@Test
	public final void add2() {
		MemoriCommandType add = MemoriCommandType.ADD;
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		Date StartDate = null;
		Date EndDate = null;
		MemoriCommand expected = new MemoriCommand(add,StartDate,EndDate,stringField);
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden");
		
		assertTrue(compareTo(result, expected));
	}

	@Test
	public final void add3() {
		MemoriCommandType add = MemoriCommandType.ADD;
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		stringField[1] = "sengKang";
		stringField[2] = "with friends";
		
		Date StartDate = DateParser.parseDate("tmr");
		Date EndDate = null;
		MemoriCommand expected = new MemoriCommand(add,StartDate,EndDate,stringField);
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden -stmr -l sengkang -d with friends");
		
		assertTrue(compareTo(result, expected));
	}
	@Test
	public final void add4() {
		MemoriCommandType add = MemoriCommandType.ADD;
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		stringField[1] = "home";
		stringField[2] = "with family";
		Date StartDate = null;
		Date EndDate = null;
		MemoriCommand expected = new MemoriCommand(add,StartDate,EndDate,stringField);
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden -l home -d with family");
		
		assertTrue(compareTo(result, expected));
	}
	@Test
	public final void add5() {
		MemoriCommandType add = MemoriCommandType.ADD;
		
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		stringField[1] = "sengKang";
		stringField[2] = "with friends";
		Date StartDate = DateParser.parseDate("thurs");
		Date EndDate = DateParser.parseDate("fri");
		MemoriCommand expected = new MemoriCommand(add,StartDate,EndDate,stringField);
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden -s thurs -e fri -l sengkang ");
		
		assertTrue(compareTo(result, expected));
	}
	@Test
	public final void add6() {
		MemoriCommandType add = MemoriCommandType.ADD;
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		stringField[1] = "sengKang";
		stringField[2] = "with friends";
		Date StartDate = null;
		Date EndDate = null;
		MemoriCommand expected = new MemoriCommand(add,StartDate,EndDate,stringField);
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden -l sengkang -d with friends ");
		
		assertTrue(compareTo(result, expected));
	}
	@Test
	public final void add7() {
		MemoriCommandType add = MemoriCommandType.ADD;
		
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		stringField[1] = "sengKang";
		stringField[2] = "with friends";
		Date StartDate = DateParser.parseDate("5 nov 9am");
		Date EndDate = DateParser.parseDate("6 nov 10pm");
		MemoriCommand expected = new MemoriCommand(add,StartDate,EndDate,stringField);
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden -s 5 nov 9am -e 6 nov 10pm -l sengkang ");
		
		assertTrue(compareTo(result, expected));
	}
	@Test
	public final void add8() {
		MemoriCommandType add = MemoriCommandType.ADD;
		
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		stringField[1] = "sengKang";
		stringField[2] = "with friends";
		Date StartDate = DateParser.parseDate("haha");
		Date EndDate = DateParser.parseDate("haha");
		MemoriCommand expected = new MemoriCommand("");
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n jayden -s haha -e haha -l sengkang -dwith friends");
		
		assertTrue(compareTo(result, expected));
	}@Test
	public final void add9() {
		MemoriCommandType add = MemoriCommandType.ADD;
		
		MemoriCommand expected = new MemoriCommand("");
		AddParser ap = new AddParser();
		MemoriCommand result = ap.parse(add, "-n -s -e -l -d");
		
		assertTrue(compareTo(result, expected));
	}
	/**
	 * compare the start date in string format , end date in string format and
	 * all the string fields of the expected and and the results of a add
	 * parser.
	 * 
	 * @param results
	 * @param expected
	 * @return
	 */
	public boolean compareTo(MemoriCommand results, MemoriCommand expected) {

		MemoriCommandType resultsCommand = results.getType();
		MemoriCommandType expectedCommand = expected.getType();
		String[] resultsArgs = results.getCommandArgs();
		String[] expectedArgs = results.getCommandArgs();
		Date expectedStartDate = expected.getStart();
		Date resultStartDate = results.getStart();
		Date expectedEndDate = expected.getEnd();
		Date resultEndDate = results.getEnd();
		
		//if both is an invalid command straight return true
		if(expectedCommand.equals(MemoriCommandType.INVALID)
				&&resultsCommand.equals(MemoriCommandType.INVALID)){
			
			return true;
		}
		// if memori command is not the same return false
		if (!resultsCommand.equals(expectedCommand)) {
			
			return false;
		}
		// if string fields of name , description location is not the same
		// return false
		for (int i = 0; i < resultsArgs.length; i++) {
			if (resultsArgs[i].equals(expectedArgs[i]) != true) {
				
				return false;
			}
		}
		// if either expectedStartDate is null but result start Date is not null
		//viseversa return false
		if (((expectedStartDate != null) && (resultStartDate == null))
				|| ((expectedStartDate == null) && (resultStartDate != null))) {
			
			return false;
		}
		// if either expectedEndDate is null but resultEndDate is not null
		//viseversa return false
		if (((expectedEndDate != null) && (resultEndDate == null))
				|| ((expectedEndDate == null) && (resultEndDate != null))) {
	
			return false;
		}
		//if both resultsStartDate and expectedStartDate is not null
		//compare the start dates
		if(((expectedStartDate != null) && (resultStartDate != null))
				|| ((expectedStartDate != null) && (resultStartDate != null))){
			
			if (!DATE_FORMATTER.format(expectedStartDate).equals(
				DATE_FORMATTER.format(resultStartDate))) {
				
				return false;
			}
		}
		//if both resultsEndDate and expectedEndDate is not null
		//compare the end dates
		if(((expectedEndDate != null) && (resultEndDate != null))
				|| ((expectedEndDate != null) && (resultEndDate != null))){
			
			if (!DATE_FORMATTER.format(expectedEndDate).equals(
				DATE_FORMATTER.format(resultEndDate))) {
				
				return false;
			}
		}

		return true;
	}
	
}
```
###### ./parsers/parserTesting/IndexesParserTest.java
``` java
package memori.parsers.parserTesting;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Collections;

import memori.parsers.IndexesParser;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;

import org.junit.Test;

public class IndexesParserTest {
	private ArrayList<Integer> ExpectedIndex;
	
	@Test
	public final void testDeleteWithNegativeNumber() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "-1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithNegativeNumber2() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "-1 1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithNegativeNumber3() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "-1 - 1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithNegativeNumber4() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "1-1-1 ";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithNegativeNumber5() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "3-1  4-5-1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithRange() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "3-1";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(1);
		ExpectedIndex.add(2);
		ExpectedIndex.add(3);
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testDeleteWithRange1() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "3   -1";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(1);
		ExpectedIndex.add(2);
		ExpectedIndex.add(3);

		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testDeleteWithRange2() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "   32     -      50  ";
		ExpectedIndex = new ArrayList<Integer>();
		addIndex(32,50);
	
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testDeleteWithRange3() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "40 ";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(40);
	
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testDeleteWithRange4() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "40   50    40             ";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(40);
		ExpectedIndex.add(50);
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testDeleteWithRange5() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "40 - 50 60 -70";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithRange6() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "40 - 50 60 -70  ";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithRange7() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "40 -  -70  ";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testDeleteWithRange8() {
		MemoriCommandType cmdType = MemoriCommandType.DELETE;
		String deleteToTest = "40-   7";
		ExpectedIndex = new ArrayList<Integer>();
		addIndex(7,40);
	
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testReadWithNegativeNumber() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "-1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithNegativeNumber2() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "-1 1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithNegativeNumber3() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "-1 - 1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithNegativeNumber4() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "1-1-1 ";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithNegativeNumber5() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "3-1  4-5-1";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithRange() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String ReadToTest = "3-1";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(1);
		ExpectedIndex.add(2);
		ExpectedIndex.add(3);
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,ReadToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testReadWithRange1() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "3   -1";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(1);
		ExpectedIndex.add(2);
		ExpectedIndex.add(3);

		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testReadWithRange2() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "   32     -      50  ";
		ExpectedIndex = new ArrayList<Integer>();
		addIndex(32,50);
	
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testReadWithRange3() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "40 ";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(40);
	
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testReadWithRange4() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "40   50    40             ";
		ExpectedIndex = new ArrayList<Integer>();
		ExpectedIndex.add(40);
		ExpectedIndex.add(50);
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	@Test
	public final void testReadWithRange5() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "40 - 50 60 -70";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithRange6() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "40 - 50 60 -70  ";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithRange7() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "40 -  -70  ";
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		assertTrue(get.getIndexes()==null);
	}
	@Test
	public final void testReadWithRange8() {
		MemoriCommandType cmdType = MemoriCommandType.READ;
		String deleteToTest = "40-   7";
		ExpectedIndex = new ArrayList<Integer>();
		addIndex(7,40);
	
		Collections.sort(ExpectedIndex);
		IndexesParser ip = new IndexesParser();
		MemoriCommand get = ip.parse(cmdType,deleteToTest);
		ArrayList<Integer> deleteResultsIndex = get.getIndexes();
		Collections.sort(deleteResultsIndex);
		assertTrue(equals(deleteResultsIndex,ExpectedIndex));
	}
	public void addIndex(int lower,int upper){
		for(;lower<upper+1;lower++){
			ExpectedIndex.add(lower);
		}
	}
	private boolean equals(ArrayList<Integer>deleteResultsIndex
			,ArrayList<Integer>deleteExpectedIndex){
		
		if(deleteResultsIndex.size()
				!=deleteExpectedIndex.size()){
			return false;
		}
		
		for(int index = 0 ; index < deleteResultsIndex.size(); index++){
			if(deleteResultsIndex.get(index)!=deleteExpectedIndex.get(index)){
				return false;
			}
		}	
		return true;
	}
}
```
###### ./parsers/parserTesting/SortParserTest.java
``` java
package memori.parsers.parserTesting;

import static org.junit.Assert.*;

import java.util.Date;

import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;
import memori.parsers.SortParser;

import org.junit.Test;

public class SortParserTest {
	
	//when the user did not indicate which field to sort
	@Test
	public final void sort1() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		MemoriCommand Expected = new MemoriCommand("");
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "");
		assertTrue(compareTo(result, Expected));
	}
	//when the user would like to sort by start
	@Test
	public final void sort2() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		Boolean[] FilledFields = new Boolean[5];
		for(int i = 0; i < FilledFields.length; i++){
			FilledFields[i] = false;
		}
		FilledFields[1] = true;
		MemoriCommand Expected = new MemoriCommand(sort,FilledFields);
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "-s");
		assertTrue(compareTo(result, Expected));
	}
	//when the user would like to sort by end
	@Test
	public final void sort3() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		Boolean[] FilledFields = new Boolean[5];
		for(int i = 0; i < FilledFields.length; i++){
			FilledFields[i] = false;
		}
		FilledFields[2] = true;
		MemoriCommand Expected = new MemoriCommand(sort,FilledFields);
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "-e");
		assertTrue(compareTo(result, Expected));
	}
	//when the user would like to sort by location
	@Test
	public final void sort4() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		Boolean[] FilledFields = new Boolean[5];
		for(int i = 0; i < FilledFields.length; i++){
			FilledFields[i] = false;
		}
		FilledFields[3] = true;
		MemoriCommand Expected = new MemoriCommand(sort,FilledFields);
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "-l");
		assertTrue(compareTo(result, Expected));
	}
	//when the user will like to sort by description
	@Test
	public final void sort5() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		Boolean[] FilledFields = new Boolean[5];
		for(int i = 0; i < FilledFields.length; i++){
			FilledFields[i] = false;
		}
		FilledFields[4] = true;
		MemoriCommand Expected = new MemoriCommand(sort,FilledFields);
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "-d");
		assertTrue(compareTo(result, Expected));
	}
	//when the user would like to sort more than one acceptable field
	@Test
	public final void sort6() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		MemoriCommand Expected = new MemoriCommand("");
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "-d -e -s");
		assertTrue(compareTo(result, Expected));
	}
	//when the user would like to sort an unacceptable 
	@Test
	public final void sort7() {
		MemoriCommandType sort = MemoriCommandType.SORT;
		MemoriCommand Expected = new MemoriCommand("");
		SortParser sp = new SortParser();
		MemoriCommand result = sp.parse(sort, "-f");
		assertTrue(compareTo(result, Expected));
	}
	/**
	 * Compare the sort fields of both expected and results
	 * @param results
	 * @param expected
	 * @return
	 */
	public boolean compareTo(MemoriCommand results, MemoriCommand expected) {
		
		Boolean[] resultsField = results.getMemoriField();
		Boolean[] expectedField = results.getMemoriField();
		if ((expectedField == null)
				&& (resultsField == null)) {
			return true;
		}
		
		for(int i = 0; i < resultsField.length; i++){
			if(resultsField[i]!=expectedField[i]){
				return false;
			}
		}
	
		return true;
	}
}
```
###### ./parsers/parserTesting/UpdateParserTest.java
``` java
package memori.parsers.parserTesting;

import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.Date;

import memori.parsers.DateParser;
import memori.parsers.MemoriCommand;
import memori.parsers.MemoriCommandType;
import memori.parsers.UpdateParser;

import org.junit.Test;

public class UpdateParserTest {
	public static final String DATE_FORMAT = "dd MMM yyyy HH:mm E";
	private static final SimpleDateFormat DATE_FORMATTER = new SimpleDateFormat(
			DATE_FORMAT);

	// test case when users did not indicate a index
	@Test
	public final void update1() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "-s");
		assertTrue(compareTo(result, expected));
	}

	// test case when user indicates that he would like to update a certain line
	// but did not enter any fields
	@Test
	public final void update2() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1");
		assertTrue(compareTo(result, expected));
	}

	// when users forgot to indicate which index he would like to update
	@Test
	public final void update3() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "-n jayden -s tmr -e tmr");
		assertTrue(compareTo(result, expected));
	}

	// a passable update case
	@Test
	public final void update4() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		Date StartDate = DateParser.parseDate("tmr");
		Date EndDate = DateParser.parseDate("tmr");
		Boolean[] FilledFields = new Boolean[5];
		for (int i = 0; i < FilledFields.length; i++) {
			FilledFields[i] = false;
		}
		FilledFields[0] = true;
		FilledFields[1] = true;
		FilledFields[2] = true;
		MemoriCommand expected = new MemoriCommand(update, StartDate, EndDate,
				stringField, 1, FilledFields);
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1 -n jayden -s tmr -e tmr");
		assertTrue(compareTo(result, expected));
	}

	// when the users never indicate a accepted field to update
	@Test
	public final void update5() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1 -q -o ");
		assertTrue(compareTo(result, expected));
	}

	// when the users dates are not of an excepted format
	@Test
	public final void update6() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1 -elove -shaha ");
		assertTrue(compareTo(result, expected));
	}

	// when the users dates are empty
	@Test
	public final void update7() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1 -e -s ");
		assertTrue(compareTo(result, expected));
	}

	// when the index is not excepted
	@Test
	public final void update8() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		MemoriCommand expected = new MemoriCommand("");
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1asdfdsfds -e -s ");
		assertTrue(compareTo(result, expected));
	}

	//allowed update 
	@Test
	public final void update9() {
		MemoriCommandType update = MemoriCommandType.UPDATE;
		
		String[] stringField = new String[3];
		stringField[0] = "jayden";
		Date StartDate = DateParser.parseDate("");
		Date EndDate = DateParser.parseDate("");
		Boolean[] FilledFields = new Boolean[5];
		for (int i = 0; i < FilledFields.length; i++) {
			FilledFields[i] = false;
		}
		FilledFields[0] = true;
		FilledFields[3] = true;
		FilledFields[4] = true;
		MemoriCommand expected = new MemoriCommand(update, StartDate, EndDate,
				stringField, 1, FilledFields);
		UpdateParser up = new UpdateParser();
		MemoriCommand result = up.parse(update, "1 -njayden -d -l");
		assertTrue(compareTo(result, expected));
	}

	/**
	 * compare the start date in string format , end date in string
	 * format,FilledFields, index to update and all the string fields of the
	 * expected and the results of updateparser.
	 * 
	 * @param results
	 * @param expected
	 * @return
	 */
	public boolean compareTo(MemoriCommand results, MemoriCommand expected) {

		MemoriCommandType resultsCommand = results.getType();
		MemoriCommandType expectedCommand = expected.getType();
		String[] resultsArgs = results.getCommandArgs();
		String[] expectedArgs = results.getCommandArgs();
		Date expectedStartDate = expected.getStart();
		Date resultStartDate = results.getStart();
		Date expectedEndDate = expected.getEnd();
		Date resultEndDate = results.getEnd();
		Boolean[] resultsField = results.getMemoriField();
		Boolean[] expectedField = results.getMemoriField();
		int expectedIndex = expected.getIndex();
		int resultsIndex = results.getIndex();
		// if both is an invalid command straight return true
		if ((expectedCommand.equals(MemoriCommandType.INVALID))
				&& (resultsCommand.equals(MemoriCommandType.INVALID))) {

			return true;
		}
		// if memori command is not the same return false
		if (!resultsCommand.equals(expectedCommand)) {

			return false;
		}
		if (resultsIndex != expectedIndex) {

			return false;
		}
		// if string fields of name , description location is not the same
		// return false
		for (int i = 0; i < resultsArgs.length; i++) {
			if (resultsArgs[i].equals(expectedArgs[i]) != true) {

				return false;
			}
		}

		if (((expectedStartDate != null) && (resultStartDate == null))
				|| ((expectedStartDate == null) && (resultStartDate != null))) {

			return false;
		}

		if (((expectedEndDate != null) && (resultEndDate == null))
				|| ((expectedEndDate == null) && (resultEndDate != null))) {

			return false;
		}

		if (((expectedStartDate != null) && (resultStartDate != null))
				|| ((expectedStartDate != null) && (resultStartDate != null))) {

			if (!DATE_FORMATTER.format(expectedStartDate).equals(
					DATE_FORMATTER.format(resultStartDate))) {

				return false;
			}
		}

		if (((expectedEndDate != null) && (resultEndDate != null))
				|| ((expectedEndDate != null) && (resultEndDate != null))) {

			if (!DATE_FORMATTER.format(expectedEndDate).equals(
					DATE_FORMATTER.format(resultEndDate))) {

				return false;
			}
		}

		for (int i = 0; i < resultsField.length; i++) {
			if (resultsField[i] != expectedField[i]) {
				return false;
			}
		}
		return true;
	}

}
```
###### ./parsers/SearchParser.java
``` java
package memori.parsers;

import java.util.Date;

public class SearchParser extends FieldsParser {
	private String INVALID_MESSAGE = "Oops, the format you try to enter is not available."
			+ "Please try again."+"\n";
	private boolean legitField = false;
	public SearchParser() {
		// TODO Auto-generated constructor stub
		init();
	}
	@Override
	public MemoriCommand parse(MemoriCommandType cmdType, String cmdFields) {
		
		extractFields(cmdFields);
		String[] StringFields = extractStrings();
		Date[] startEnd = extractSearchDates();
		UpdateFilledFields();
		updateLegitField();
		
		if(legitField == false){
			
			return new MemoriCommand(INVALID_MESSAGE);
		}
		
		if((FilledFields[START_INDEX]==true)&&(FilledFields[END_INDEX]==true)){
			
			if((startEnd[0]!=null)&&(startEnd[1]!=null)){
				
				return new MemoriCommand(cmdType,startEnd[0],startEnd[1],StringFields);
			
			}else{
				
				return new MemoriCommand(INVALID_MESSAGE);
			}
		
		}else if((FilledFields[START_INDEX]==false)&&(FilledFields[END_INDEX]==false)){
				
			return new MemoriCommand(cmdType,startEnd[0],startEnd[1],StringFields);
		
		}else{
			
			return new MemoriCommand(INVALID_MESSAGE);
		
		}
	}
	public void updateLegitField(){
		for(int i = 0;i < FilledFields.length; i++){
			if(FilledFields[i]==true){
				legitField = true; 
			}
		}
		
	}
}
```
###### ./parsers/SortParser.java
``` java
package memori.parsers;


public class SortParser extends FieldsParser{
	private boolean legitField = false;
	private int numberOfSorts = 0;
	private static final String INVALID_MESSAGE = "Oops,invalid sort format.Please try again."+"\n";
	public SortParser(){
		init();
	}
	@Override
	//change does not allow user to type in more than one fields
	public MemoriCommand parse(MemoriCommandType cmdType, String cmdFields) {
		extractFields(cmdFields);
		UpdateFilledFields();
		updateLegitField();
		if((legitField == false)||(numberOfSorts > 1)){
			return new MemoriCommand(INVALID_MESSAGE);
		}
		return new MemoriCommand(cmdType,FilledFields);
	}
	/*check if the user actually enters a legit sort field
	 * check update how many sort field that the user has entered
	 */
	private void updateLegitField(){
		for(int index = 0;index < FilledFields.length; index++){
			if(FilledFields[index]==true){
				legitField = true; 
				numberOfSorts++;
			}
		}
		
	}
}
```
###### ./parsers/SystemParser.java
``` java
package memori.parsers;

public class SystemParser extends FieldsParser {
    public SystemParser(){
    	init();
    }
	@Override
	public MemoriCommand parse(MemoriCommandType cmdType, String fields) {
		// TODO Auto-generated method stub
		return new MemoriCommand(cmdType);
	}
	
}
```
###### ./parsers/UpdateParser.java
``` java
package memori.parsers;

import java.util.Date;

public class UpdateParser extends FieldsParser {
	private static final String INVALID_FIELD_MESSAGE = "Oops,there are no fields indicate to update."
			+ "Please try again."+"\n";
	private static final String INVALID_NAME_MESSAGE = "Oops,update name is blank."
			+ "Please try again."+"\n";
	private static final String INVALID_MESSAGE = "Oops,index you try to update is not available."
			+ "Please try again."+"\n";
	private static final String INVALID_DATE_MESSAGE = "Oops,invalid date format."
			+ "Please try again."+"\n";
	private boolean legitField = false;
	public UpdateParser() {
		// TODO Auto-generated constructor stub
		init();
	}

	@Override
	public MemoriCommand parse(MemoriCommandType cmdType, String fields) {
		try{
			String[] splitted = fields.split(" ",2);
			if(splitted.length == 2){
				int index = Integer.parseInt(splitted[0]);
				extractFields(splitted[1]);
				String[] stringFields = extractStrings(); 
				Date[] startEnd = extractDates();
				UpdateFilledFields();
				updateLegitField();
				if(legitField == false){
					
					return new MemoriCommand(INVALID_FIELD_MESSAGE);
				}
				if((FilledFields[NAME_INDEX]==true)&&(stringFields[0].equals(""))){
					
					return new MemoriCommand(INVALID_NAME_MESSAGE);
				}
				if((FilledFields[START_INDEX]==true)&&(startEnd[0]==null)){
					return new MemoriCommand(INVALID_DATE_MESSAGE);
				}
				if((FilledFields[END_INDEX]==true)&&(startEnd[1]==null)){
					return new MemoriCommand(INVALID_DATE_MESSAGE);
				}
				
				return new MemoriCommand(cmdType,startEnd[0],startEnd[1],stringFields,index,FilledFields);
			
			}
			
			return new MemoriCommand(INVALID_FIELD_MESSAGE);
			
		}catch(NumberFormatException e){
			
			return new MemoriCommand(INVALID_MESSAGE);
		}
	}
	/*check whether the user has indicated that he would like to update at least one field
	 * 
	 */
	public void updateLegitField(){
		for(int i = 0;i < FilledFields.length; i++){
			if(FilledFields[i]==true){
				legitField = true; 
			}
		}
		
	}
}
```
